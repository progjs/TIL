3. 어려운 기술적 문제를 해결한 경험을 상세히 작성해주세요. (학교수업/프로젝트/경진대회/대외활동 등)
   어떤 문제였는지 '구체적'으로 기술하고, 본인의 접근방법과 실제 결과가 어땠는지 '자세히' 설명해주시기 바랍니다.
   해결하지 못한 경험이더라도 해결을 위해 얼마나 깊이 있게 고민을 했는지 그 과정에 대해 이야기해주세요.
   #코드로 설명해도 좋아요 #해결 못한 경험도 좋아요 #과정을 보고 싶어요



<영화 검색/추천 웹 서비스>

목표 : 명작인 영화를 검색하고 추천할 수 있는 웹 서비스 개발.

Django Framework를 기반으로 MariaDB, jQuery, Javascript, Ajax, HTML5, CSS로 개발했습니다.



[워드 클라우드 제작 및 자동화]

영화별 워드 클라우드를 제작해 영화의 ID.png 로 저장한다. 워드 클라우드 이미지 갱신을 자동화한다.

1. 영화별 댓글을 모두 조회해 중첩 리스트에 저장. 댓글이 존재하지만, 영화 제목이 존재하지 않는 등의 garbage data를 발견.

 1-1. 영화 table에서 empty 값을 가진 record를 제거. 외래키로 참조되어 있던 댓글도 함께 제거된다.

 1-2. pymysql 모듈로 connect 해서 쿼리문으로 cursor의 값을 조회했다. 영화 ID를 먼저 조회하고 이에 매칭되는 댓글 데이터를 조회.

 1-3. 댓글에서 normalize로 영어, 한글, 숫자만을 추출.

2. 댓글에서 단어를 추출하고 {단어:빈도수} 형식의 dictionary로 저장. "그리고, 봤는데" 등의 빈도수가 높은 불용어 발견.

 2-1. KoNLP로 단어를 추출하고 빈도수 순으로 dictionary에 저장.-keywords 라는 이름으로 저장. KoNLP가 비교적 실행속도가 느리다고 생각함.

 2-2. 직접 불용어 사전을 만들어 단어와의 교집합을 keywords에서 제거.

 2-3. 빈도수 순으로 정렬된 keywords를 확인하며 주로 빈도수가 높은 불용어부터 사전에 추가하는 방식을 반복해서 불용어 사전을 갱신.

3. 워드 클라우드 제작할 때 단어가 많아 주요 키워드가 눈에 띄지 않는 점을 발견.

 3-1. 빈도수가 높은 상위 610개의 단어를 사용해 워드 클라우드 생성.

 3-2. 단어가 610개 이하인 영화는 모든 단어를 사용해 워드 클라우드 생성.

4. 워드 클라우드 갱신을 자동화.

 현재 초기 자료로 네이버 영화의 추천 댓글 100개를 사용해 워드 클라우드를 생성했지만, 새로 추가된 댓글을 워드 클라우드에 반영할 수 없다. 워드 클라우드 갱신을 자동화해야 한다.

 4-1. 자동화 모듈을 찾아보다 cron이 가장 효율적이고 예제가 많아 선택.

 4-2. test해보지만 실행되지 않아 원인을 찾아보다가 Linux에서 사용하는 모듈이라는 것을 알게 되었다.

 4-3. Window 기반 스케줄러 모듈인 schedule을 사용하기로 결정.

 4-4. 워드 클라우드 소스 코드를 역할별로 함수화하여 정리하고 .py 모듈로 만들어 Django 프로젝트에 추가.

 4-5. views.py에서 schedule 모듈로 테스트를 진행. 성공했지만 서비스와 동시 실행이 되지 않음.

 원인은 while True: schedule.run_peding().. 로 앱을 run 하지 못하고 계속 자동화만 수행하는 것이었다.

 4-6. views.py에서 thread로 자동화를 실행하도록 구현. 매주 월요일마다 워드 클라우드가 갱신되도록 설정.



[영화 추천 기능]

목표: 홈 화면에서 장르를 선택하면 선택한 장르의 영화 중에서 추천해야 한다. 그러나 동기 통신으로 추천 영화 목록이 변경되도록 구현되어 있어, 이를 비동기 통신으로 변경하고자 한다.

1. template에서 선택한 장르를 view로 전송.

 1-1. AJAX를 활용. 선택한 장르 태그의 값을 JSON 형식으로 view에 전송. view에서 print로 확인.

2. views에서 선택한 장르로 한정하여 추천 로직을 적용. print 해서 결과 확인.

3. 영화 query set을 JSON으로 template에 전송하는 것이 실패함.

 3-1. 원인을 console.log와 print로 확인. 객체로 이루어진 query set은 JSON 데이터로 dump가 되지 않는 문제 발견.

 3-2. template에서 필요한 값들을 정리하며 따로 dictionary에 저장해 JSON으로 dump를 시도. 그러나 template에서 필요한 값이 많아 다른 방법을 모색.

 3-3. serializers로 query set을 JSON으로 변환하여 template에 전송.

4. jQuery로 추천 영화 목록 갱신.

 4-1.console.log로 응답받은 데이터의 형식을 파악하고 JSON 데이터를 Javascript 객체로 변환하여 추천 영화 목록을 갱신.

 4-2. 영화 포스터 이미지가 서로 겹치거나 포스터 이미지 크기가 제각각인 문제 발생.

 4-3. 영화 포스터의 크기가 모두 다르고, 이전 영화 포스터의 크기와 grid에 새로운 영화 포스터가 삽입되는 것이 원인. 이미지의 가로/세로 최소 길이를 지정해서 문제 해결.

5. 추천 로직 변경.

 5-1. 영화 평점 순으로 추천 영화 목록을 만들기로 결정.

 5-2. 특정 영화만 반복적으로 나오는 것을 확인. 최소 평점을 넘은 영화 중 랜덤하게 추천.

 5-3. 옛날 영화와 최신 영화의 밸런스가 맞지 않아, 2010년을 기준으로 전후의 영화를 4:5 비율로 추천.

 5-4. 회원 정보의 가장 선호하는 장르를 추천 로직에 반영.



[댓글 - 별점 기능]

Django Forms를 활용해 선택한 별점(평점)을 DB에 저장한다. 5개의 별로 1~10점을 구현해야 하고 별을 클릭할 때마다 입력한 평점 값과 별의 모양을 실시간으로 변경해주는 것에서 어려움을 겪었습니다.

1. 평점을 별 모양으로 만들어 사용자가 클릭할 때마다 별 모양이 변경되도록 구현.

 1-1. 많이 사용하는 기능이기 때문에 오픈소스를 찾아서 적용을 시도. rateit.js를 활용하기 위해 readme 파일을 읽어 사용법을 파악하고 HTML 파일에 적용. 적합한 별점 기능을 찾고 매개변수를 부여해 브라우저에 보이도록 성공.

 1-2. 댓글 Form을 만들 때 rateit.js를 새로운 widget으로 만들어 적용해야 하는 문제 발생.

2. 차선책을 찾음. Javascript로 img 태그의 이미지를 채워진 별/빈 별/반만 채워진 별로 태그의 class별로 CSS를 구현하고, 별을 click할 때마다 변경을 시도.

 2-1. 별 이미지를 static 템플릿 태그로 불러오는 데 실패해서 직접 이미지 경로를 대입해 적용.

 2-2. 7점을 클릭하면 3개의 별이 색칠되고 4번째 별이 반만 채워져야 하지만, 앞의 3개의 별이 종종 변하지 않음.

 2-3. 검색해서 on 클래스를 정의한 CSS 소스 코드를 활용해서 star click 기능 구현.

 2-4. for 문으로 클릭한 점수보다 적은 점수에 해당하는 별을 속이 채워진 별 이미지로 변경한다. 선택된 점수를 view에서 처리하기 위해 img tag의 value 속성에 평점 값을 hidden input 태그에 전달.



<서울시 가로 휴지통 부족 문제 해결을 위한 데이터 분석 과제>

서울시 가로 휴지통 부족 문제를 해결하기 위해 자치구와 동별로 적절한 휴지통 개수를 예측하는 모델을 만든다.  문제 상황을 분석하면서 가로 휴지통 개수와 관련된 요인들을 선정하고 데이터를 수집. 버스정류장/지하철역/상권 유동인구, 테이크 아웃 업종 수, 재정자립도, 거주인구, 동별 면적 데이터 사용.

1. 분석 모델 선정을 위해 간단히 가공한 데이터로 SVR, 랜덤 포레스트, 회귀나무, 다중선형회귀분석을 시행하고 설명력을 비교.

   1-1. 모든 분석 방법의 RMSE가 높음. (낮을수록 설명력이 높다)

   1-2. 그중 제일 RMSE가 낮은 SVR를 사용하려 했으나, 다중선형회귀분석으로 결정. 

   회귀분석은 모델에서 변수별 p-value와 회귀계수를 수치로 확인할 수 있기 때문에 이를 통해 데이터를 다르게 처리하며 모델을 최적화하기로 결정. (과거에 읽었던 학생 논문에서 착안)

2. 다중선형회귀분석으로 모델링.

   1-3. 회귀분석에 관한 논문과 분석 사례를 찾아보며 해결방안을 모델링에 적용.

   1-4. 상관분석을 확인하고 변수들을 더미 변수화 하여 p-value를 낮춰 변수 선택법을 실시.

   1-5. 팀원이 만든 자치구 청결 척도를 더미 변수로 변환해 추가하여 adjusted R-squared 값을 높이고 모델의 -value를 낮춰 모델 최적화.

------

4. 본인이 가장 재미를 느끼고 끝까지 파고들어 본 경험 또는 성취감을 느꼈던 경험이나,
   성장할 수 있는 계기가 되었던 경험이 있었다면 얘기해주세요.
   그 경험을 통해 배운 점이 무엇인지, 본인의 '어떤 부분이 성장'했는지에 대해 작성해주세요.
   공부, 개발, 색다른 경험, 취미활동 등 어떤 분야의 경험이라도 좋습니다.
   #다양한 이야기를 듣고싶어요 #어떤 경험이든 배운 점이 있다면 들려주세요 #나만의 성장스토리 궁금해요

   

[내가 쓴 기사 한 페이지의 영향력]

1년 동안 통계청 대학생기자단으로 활동하면서 기사의 목적을 확실하게 정하고 다양한 주제에 통계를 접목해 기사를 작성하기 위해 노력했습니다.



기자단에 지원할 때 작성하는 자유 기사의 주제로 생리컵을 선정했습니다. 생리컵에 대한 부정적 인식과 월경 용품에 관한 통계자료를 인용해 생리컵을 소개하는 기사였습니다.

기자단 면접에서 생리컵이 너무 민감한 주제라는 지적을 받았지만, 저의 기획 의도를 솔직하게 말해 기자단에 합격할 수 있었습니다. 저는 통계청 블로그가 더 다양한 주제를 담고 사회의 올바른 변화에 도모하길 바란다고 답했습니다. 월경이 부끄러운 것이 아님에도 아직 사회에서는 월경을 ‘그날’이라 돌려 말하고 월경 용품을 당당히 꺼낼 수 없는 현실을 바꾸는 데에 저의 기사가 조금이라도 선한 영향력을 행사하기를 바랐습니다. 그러나 통계청이라는 공기관에서 직접 월경을 표현하기에는 무리가 있다고 판단했습니다. 그래서 사회적으로 이슈화되었던 생리대 파동과 광고, 생리컵을 소재로 기사를 작성했습니다.

이 기사를 작성하기 전까지는 저도 수동적인 사람이었습니다. 다수에 따라 행동하고 순응하는 편이었습니다. 그러나 생리컵 기사를 작성하면서 변화를 도모하는 자세를 가지게 되었습니다. 그리고 면접에서 기획 의도를 답변하면서 내 생각을 명확하게 말로 표현하는 것이 중요함을 알게 되었습니다. 그러기 위해서는 나의 의견을 정리하고 내 생각에 확신을 가지고 있어야 한다는 것도 느꼈습니다.



이후 통계청 기자단이 되어 다양한 주제의 기사를 작성했습니다. 어글리슈즈를 주제로 기사를 쓸 때는 관련 통계가 없어, 네이버 데이터랩과 해외 패션 통계를 활용해 직접 통계를 만들었습니다. 독도 방문하고, 독도명예주민증을 SNS에 인증하자! 는 주제로 기사를 작성하기도 했습니다. 이를 위해 직접 관리사무소에 연락해 최신 데이터를 수집해 통계를 만들기도 하고, 방문자와 SNS로 인터뷰하여 생생함을 기사에 담기 위해 노력했습니다. 매번 기사를 작성할 때에는 가독성, 앞뒤 문맥을 고려하고, 예쁘고 이해하기 쉬운 통계자료를 제작하기 위해 고민도 많이 했습니다. 덕분에 웹 프론트를 개발할 때에도 개발이 용이한 것보다, 사용자의 관점에서 웹 페이지를 구성하고 시나리오를 기획할 수 있었습니다.

1년 동안 남다른 기사를 만들기 위해 발로 뛰면서 저의 적극성을 발견했습니다. 저의 다양한 주제를 보고 다른 기자들도 색다른 주제를 고민해보게 되었다는 말을 들으면서, 저도 누군가에게 영향력을 미칠 수 있다는 것을 체감했습니다. 그래서 앞으로도 대단한 것이 아니더라도 타인에게 긍정적인 영향을 주고 싶습니다.



------

5. 만약 네이버 입사 후 3년의 시간이 지났다면 어떤 개발자가 되어 있을까요?

* 작성예시 : 어떤 분야에서, 어떤 개발자가 되어 있을지 또는 네이버의 어떤 서비스를 어떻게 개선해 나가고 있을지 등
  #내가 꿈꾸는 네이버 개발자로서의 미래 #구체적일수록 좋아요

  

[Python으로 개발하고 싶습니다]
Python으로 어떤 서비스라도 한 가지 개선하거나 개발해 본 경험을 가진 개발자가 되고 싶습니다. Python은 제가 처음 코딩을 접한 언어이고 가장 좋아하는 언어입니다. 그래서 개발자가 된다면 Python으로 개발해보고 싶습니다. Python은 웹과 임베디드, 데이터 처리와 분석에 활용할 수 있는 언어입니다. 네이버의 웹 서비스는 대부분 자바 기반으로 구현되어 있으리라 생각합니다. 그래서 저는 네이버에서 데이터 분석 및 가공에 Python을 사용하고 싶습니다. 나아가 직접 Python 모듈을 만들어 Github과 pypi로 배포하고 싶습니다.



[이런 개발자가 되고 싶습니다]
제가 직접 사용해보고 그 서비스를 개선하거나, 나를 포함한 사용자에게 필요한 서비스를 개발하는 개발자가 되고 싶습니다. 제가 경험한 두 번의 개발 프로젝트는 평소 제가 원했던 기능을 담은 서비스를 개발하는 것이었습니다.
개인맞춤형 메뉴 추천 서비스-니맛내맛은 단순하게 매일 무엇을 먹을지 고민했던 저의 경험과, 음식을 많이 가려 먹는 친구를 생각하며 만들어보게 된 서비스입니다. 꼭 한번 개발해보고 싶다는 생각으로 메모장에 적어 두었던 음식 추천 서비스를 웹앱으로 개발해보게 되었습니다. 설문조사로 300명의 니즈를 반영해, 여러 명의 식성을 고려한 그룹 메뉴 추천 기능도 추가했습니다.
영화 검색/추천 서비스는 네이버 영화를 이용하다가 개발해보게 된 서비스입니다. 네이버 영화로 몇몇 영화를 검색해 평가를 찾아보다가 시간을 많이 소요해 지쳐 잠들던 때가 종종 있었습니다. 네이버는 사용자가 많아 댓글도 많고 평가도 다양했습니다. 댓글을 읽다 보니 피로도가 쌓여 정작 영화를 보지는 못하게 되었습니다. 그래서 저는 영화의 댓글을 워드 클라우드로 시각화하여 사용자에게 제공하는 웹 서비스를 개발했습니다. 네이버 개발자가 된다면 워드 클라우드 기능을 네이버 영화에 직접 추가해보고 싶네요.
이처럼 저는 저 자신이 필요성에 공감할 수 있는 서비스를 개발하고 싶습니다. 개발 후 다양한 사용자와 지인들에게 제가 개발한 서비스의 평가를 받고 개선사항과 서비스의 장점을 수용할 것입니다. 장점은 다음 개발에서 활용하고, 개선사항은 빠르게 수정할 것입니다. 비록 주어진 개발 과제가 경험해보지 못한 기술이라도 서비스의 당위성을 생각하며 새로운 기술을 배우고 도전하는 자세를 가질 것입니다.

------



```python

def choice_movies(past_cnt, cur_cnt):
    past_id = Movie.objects.filter(release_year__lte=2010, score__gte=8.8).values_list('pk', flat=True)
    choice_id_list = sample(list(past_id), past_cnt)
    cur_id = Movie.objects.filter(release_year__gt=2010, score__gte=8.5).values_list('pk', flat=True)
    choice_id_list += sample(list(cur_id), cur_cnt)
    return choice_id_list


def filter_all(request):
    if 'user_id' in request.session.keys():
        user = get_object_or_404(User, username=request.session['user_id'])
        user_genre = get_object_or_404(UserDetail, user=user).favorite_genre
        genre_movie_id = Movie.objects.filter(genres__genre=user_genre, score__gte=8).values_list('pk', flat=True)
        choice_id = sample(list(genre_movie_id), 3) + choice_movies(3, 3)
    else:
        choice_id = choice_movies(4, 5)
    movie_list = Movie.objects.filter(pk__in=choice_id)
    return movie_list


def index(request):
    # delete_garbage_movie()
    movie_list = filter_all(request)
    return render(request, 'movieapp/index.html', {'movie_list': movie_list})


def index_filter(request):
    genre = request.POST.get('genre')
    if genre == 'all':
        genre_movies = filter_all(request)
    else:
        print('선택한 장르', genre)
        genre_movie_id = Movie.objects.filter(genres__genre=genre, score__gte=8).values_list('pk', flat=True)
        choice_id = sample(list(genre_movie_id), 9)
        genre_movies = Movie.objects.filter(pk__in=choice_id)

    movie_list = serializers.serialize('json', genre_movies)
    data = {"movie_data": movie_list}
    for movie in genre_movies:
        movie_genres = movie.genres.all()[:3]  # 대표 장르 3개
        data[movie.pk] = serializers.serialize('json', movie_genres)
    return HttpResponse(json.dumps(data), content_type="application/json")

```

